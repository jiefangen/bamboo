# 数据库开发设计规约

## 一、技术选型

### 1.1 数据库选型
1. MySQL
    - 单表行数不超过千万，通过有限的分表可以将规模降低到千万以下的亦可
    - 具有复杂的查询需求，且对这种复杂查询的性能要求不高
    - 对主键有特殊要求，如：特定业务格式/必须数字/自增等
2. MongoDB
    - 单表行数超过千万，无法通过有限分表降低规模
    - 查询逻辑简单，对查询的性能要求较高
    - 可以接受24位十六进制字符串的主键
    - 时间具有重要业务意义、多插入和查询、少修改的场景（如：日志、交易记录）是最佳应用场景
3. Redis
    - 缓存
    - 读写分离
    - 分布式锁
4. 图数据库
    - 海量高价值关系
    - 业务需求包含对这些关系的基于图论学的运算，如：最短路径
    - Neo4j：产品成熟，市场占有率最高，图形界面工具完善，免费的社区版只能部署为单实例不能做集群，只支持冷备份不支持热备份，最多支持320亿个节点、320亿个关系、640亿个属性，在此限制范围内可考虑选择社区版，企业版过于昂贵（3.6~
   19.9万美元/年），基本不考虑
    - JanusGraph：免费开源的图数据库，支持多种存储引擎和索引引擎，但未成为成熟的产品，配置麻烦，难于使用，管理工具欠缺，图形界面工具未找到好用的，实际使用还需要很多投入
#### 选型建议
- 在条件允许的情况下，优先使用MySQL，其次MongoDB，Redis和图数据库仅应用于适合的特殊场景

### 1.2 消息队列选型
1. RocketMQ
   - 单机吞吐量：十万级
   - 可用性：非常高，分布式架构
   - 消息可靠性：经过参数优化配置，消息可以做到0丢失
   - 具有金融级的稳定性，低延迟，且分布式事务能力
   - 源码是java，对java项目集成可扩展性高
2. RabbitMQ
   - 单机吞吐量：万级
   - 可用性：高，主从架构
   - 时效性：微秒级，性能极其好，并发能力强
   - 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；
3. Kafka
   - 单机吞吐量：十万级
   - 可用性：非常高，分布式架构
   - 功能较为简单，主要支持简单的MQ功能
   - 实时计算以及日志采集领域，被大规模使用

#### 选型建议
- 如果你需要处理大规模的实时数据，特别是在大数据领域，或者分布式日志收集，Kafka是一个不错的选择
- 如果应用对消息的可靠性、顺序或者事务有严格的要求，RocketMQ提供了较好的支持
- 如果应用相对较小，或者你更注重消息队列的简单易用性，RabbitMQ可能是更合适的选择

## 二、通用规约

1. 【强制】数据库名称全部小写，多个单词之间用下划线分隔，禁止使用任何下划线外的特殊字符，禁止使用数字开头。
2. 【推荐】一个微服务原则上只使用一个数据源。
    - 说明：一个微服务应该是一个相对独立的业务模块，使用一个专属的数据源进行数据持久化，如果要使用其它模块的数据，应该通过调用其它模块的接口访问数据，而不应该直接访问其它模块的专属数据源。
    - 注意：特定场景下可以额外使用辅助数据源，但需要注意事务问题，如果需要进行多数据源事务控制，则需纳入seata全局事务管理体系。
3. 【强制】微服务使用的主数据库名称应与微服务名称对应，均包含关键业务标识，以便于识别。
    - 正例：权限微服务名称 auth-service，数据库名称 auth
    - 反例：权限微服务名称 auth-service，数据库名称 user

## 三、MySQL规约

    本小节从《阿里巴巴Java开发手册》-MySQL数据库章节引用或改编

1. 【强制】所有数据库标识符一律不使用大写字母，多个单词之间用下划线分隔。
   > 说明：数据库标识符包括：数据库名、表名、字段名、索引名等，MySQL在不同操作系统下，默认对标识符字母大小写的敏感度是不同的，为保持一致性一律不使用大写。
2. 【强制】禁止使用存储过程和触发器。
   > 说明：系统最大的瓶颈就在数据库，数据库可扩展性远没有应用服务强，我们应该尽可能将消耗从数据库中剥离出来，而存储过程和触发器的作用都是应用服务可以替代的；  
   同时，存储过程和触发器的滥用会大概率在数据库中留存业务逻辑代码，可维护性极差；
3. 【推荐】谨慎使用外键约束。
   > 说明：外键约束的作用是维护数据引用的一致性，但同时带来插入性能损耗；  
   如果更新约束为级联（CASCADE），则存在级联更新风暴的风险，且级联更新是强阻塞的；  
   如果删除约束为级联（CASCADE），则存在错误过度删除的风险；  
   如果业务上不能容忍和处理任何引用错误，对数据引用一致性的要求高于对性能的要求，则需要使用外键约束，但务必注意：更新和删除的约束均应该为RESTRICT。

### 3.1 表规约

1. 【强制】表名为t_表本名；单一主键字段一律为id，主键名为pk_表本名，唯一索引名为uk_字段名，普通索引名为idx_字段名，以下划线分隔多个字段。
   > 说明：t_即table，pk_即primary key，uk_即unique key，idx_即index的缩写。  
   例外: 当一个库中表过多时（如超过50个），表名可以模块名加下划线开头而不是t_开头，如：base_
2. 【强制】外键名称需在一个数据库中唯一，其命名为fk_表本名_字段名，其对应的索引名与外键名保持相同。
3. 【强制】表名中的表本名以对应的实体类名为基础，全小写化，多个单词间以下划线分隔，且一律采用名词单数形式，不使用复数
   > 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应的实体类名也是单数形式，符合表达习惯。  
   正例：实体类 UserAuthority，表名 t_user_authority  
   反例：user_authority，t_userauthority，t_user_authorities
4. 【强制】唯一性约束命名为uk_表本名_字段名，多个字段名之间用双下划线（__）分隔。
5. 【推荐】多对多关系表的表名为：t_左表本名_右表本名_relation
   > 例如：t_manager_role_relation
6. 【推荐】单表行数超过500万或者单表容量超过2GB，才推荐进行分表；单表行数超过千万行或者单表容量超过4GB，则应该进行分表。
   > 说明：如果预计三年后数据规模不会达到这个规模，则不要创建之初就分表。

### 3.2 字段规约

1. 【强制】表中的字段名以对应的实体类属性名为基础，全小写化，多个单词间以下划线分隔，但禁用MySQL关键字，如：name、desc等，请参考MySQL官方关键字
   > 建议：有时实体类属性名即为MySQL关键字，对应的数据库表字段名无法使用，此时可考虑采用表本名_字段名的形式。  
   正例：角色表t_role中的role_name，商品表t_product中的product_desc
2. 【强制】小数字段类型必须为decimal，禁止使用float和double
   > 说明：float和double在存储时存在精度损失问题。  
   建议：如果数据范围超过decimal能表达的范围，可拆分为整数和小数两个部分分开存储。
3. 【强制】字符串型字段，如果不同记录该字段的内容长度几乎都相等，则使用char定长字符串类型，否则使用varchar变长字符串类型
4. 【强制】varchar变长字符串类型的长度不要超过4000，如果确实需要超过，则应该使用text字段类型，且单独建表，用相同主键对应，避免影响其它字段的索引效率
5. 【推荐】针对时间型字段，尽量避免使用timestamp（2038年问题），当时间只需精确到秒时用datetime，如果需精确到毫秒，则可以使用bigint或char（字符串格式的时间），
   前者空间占用更少，性能比后者快约一倍，但手写sql赋值不便，通用性和可读性差，只能精确到毫秒，不能精确到纳秒，后者则正好相反
6. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应满足以下所有条件：   
   1） 不是频繁修改的字段。   
   2） 不是varchar超长字段，更不能是text字段。   
   3） 不是唯一索引的字段。
   > 正例：商品类目名称使用频率高，字段长度短，名称基本不变，可在相关联的表中冗余存储类目名称，避免关联查询。
7. 【参考】字段长度在符合业务要求的前提下尽可能短。
   > 说明：不但节约数据库表空间，节约索引存储，更重要的是提升检索速度。  
   反例：整数字段无脑使用int类型，甚至布尔字段都使用int类型
8. 【参考】一些常见类型的字段长度设计。
   > 名称类：20位字符串，如：姓名、用户名、显示名称、昵称、企业简称  
   标题类：50位字符串，如：标题、企业全称 说明类：200位字符串，如：说明、备注、简介、简要描述  
   URL类：256位字符串 介绍类：4000位字符串，如：详细介绍、完整描述 文章类：65535位字符串，如：文章内容 金额类：(12,2)位数字 比例类：(5,4)位数字

### 3.3 索引规约

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
   > 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。
2. 【强制】需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。
3. 【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。
   > 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。
4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
   > 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
5. 【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。
   > 正例：where a=? and b=? order by c; 索引：a_b_c  
   反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a> 10 ORDER BY b; 索引a_b无法排序。
6. 【推荐】利用覆盖索引来进行查询操作，避免回表。
   > 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。  
   正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。
7. 【推荐】利用延迟关联或者子查询优化超多分页场景。
   > 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。  
   正例：先快速定位需要获取的id段，然后再关联：SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
8. 【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。
   > 说明：  
   1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。  
   2） ref 指的是使用普通的索引（normal index）。   
   3） range 对索引进行范围检索。  
   反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。
9. 【推荐】建组合索引的时候，区分度最高的在最左边。
   > 正例：如果where a=? and b=? ，如果a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。  
   说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c> ? and d=? 那么即使c的区分度更高，也必须把d放在索引的最前列，即索引idx_d_c。
10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。
11. 【参考】创建索引时避免有如下极端误解：
    > 1） 宁滥勿缺，认为一个查询就需要建一个索引；  
    2） 宁缺勿滥，认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度；  
    3） 抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决；

## 四、MongoDB规约

1. 【强制】MongoDB与关系型数据库相似但也有很多区别，务必先了解清楚MongoDB中与关系型数据库对应的各个概念。
   > 说明：包括集合、文档、字段、索引、主键等。
2. 【强制】集合名称、字段名称都根据spring-data-mongodb的规则，从实体类中自动生成。
   > 说明：MongoDB的集合结构是不确定的，像MySQL那样事先通过脚本确定结构没有意义。

### 4.1 集合规约

1. 【推荐】如果因为数据量的原因选择MongoDB，那么在设计集合时要考虑，不要出现大量的关联查询，更不要出现复杂的关联查询。
   > 说明：MongoDB不支持复杂的Join，且关联查询语句复杂、可读性差，太多或太复杂都非常不利于维护。
2. 【推荐】集合数量不宜太多。
   > 说明：集合数量应该小于同样业务使用关系型数据库时的表数量，关系型数据库有多对多关联表，一对多关联也会使用两个表，而MongoDB可以考虑内嵌在一个集合中
3. 【推荐】一对多（<100）的关系使用全部内嵌
   > 说明：一对多关系中，如果多端数量较少且变化较少，如：一个人有几个收货地址，应该将多端数据全部内嵌到一端的集合中，用数组形式存放，多端实体没有对应集合。
4. 【推荐】一对多（千级别）的关系使用主键内嵌
   > 说明：一对多关系中，如果多端数量较多且变化量可控，如：一个企业下有几千名员工，多端实体应该映射为一个集合，并在一端集合中内嵌多端集合的主键数组。
5. 【推荐】一对多（万以上）的关系使用连接引用
   > 说明：一对多关系中，如果多端数量很多且会频繁增长，如：一个用户的操作记录，多端实体应该映射为一个集合，并加入对一端集合的连接引用；  
   此时实际上未使用一对多关联，使用的是多对一关联
6. 【推荐】经常更新的数据不要放在大的内嵌数组中。
   > 说明：MongoDB定位数组中元素的能力弱，只能定位第一个数组元素，如果需要更新数组中其它元素，需要将整个数组读取到内存中，更新元素之后整个数组保存到数据库；  
   这也是上述三个与一对多关系相关的规约之所以这样设定的根本原因。

### 4.2 字段规约

1. 【强制】使用默认的主键生成策略，不要自行指定主键值。
   > 说明：MongoDB通过类似UUID的生成策略，在单个节点上快速生成全局唯一的主键，表现形式为24位十六进制字符串；  
   如果应用服务自行指定主键值，则MongoDB需到所有分布式节点上检查唯一性，性能随着数据量的增加下降明显。
2. 【推荐】相比关系型数据库，可以更宽松地采用冗余字段。
   > 说明：MongoDB的关联查询能力大大低于关系型数据库，为查询方便和性能考虑，相比关系型数据库，MongoDB使用冗余字段的条件更宽松；  
   只要不是频繁更新的字段，均可以考虑进行冗余。

### 4.3 索引规约

1. 【推荐】为查询条件建立合适的索引。
   > 说明：MongoDB中索引对改动（插入和更新）的性能影响远大于关系型数据库，除主键索引外其它索引的建立，应认真权衡好对查询性能的提升和对改动性能的降低之间的利弊。
2. 【推荐】组合索引优于交叉索引。
   > 说明：组合索引是同时包含多个字段的索引，交叉索引是每个字段各自有索引，查询时使用这些单字段索引进行交叉获得查询结果。MongoDB中交叉索引触发率较低，应尽可能使用组合索引；  
   注意：如果为了兼顾多种查询场景，一个集合上建立了多个不同字段组合情况的组合索引，导致索引数量众多，将大大降低数据改动的性能。
3. 【推荐】组合索引中的字段顺序：等于条件字段在前，范围条件字段在后。
   > 说明：这一点与MySQL是相同的。
4. 【推荐】尽量使用覆盖索引。
   > 说明：这一点与MySQL是相同的。
5. 【参考】慎用唯一索引。
   > 说明：MongoDB在检查字段值的唯一性时，需要到所有分布式节点上都检查一遍，性能随着数据量的增加而下降明显。 注意：MongoDB会将所有未赋值字段视为null，如果确实使用了唯一索引，则要注意，MongoDB会将所有null视为相等，此时两个null值会被判定为重复。为解决这个问题，唯一索引中的字段如果可能为null，我们需要打上稀疏索引标记：

    ```
    db.collection("test").createIndex({"name": 1}, {unique: true, sparse: true})
    ```

### 4.4 开发规约

1. 【强制】只需要一个MongoClient实例。
   > 说明：MongoClient是线程安全的，自带连接池，在一个JVM内不需要实例化多个，避免不必要的资源浪费。
2. 【推荐】更新时推荐使用字段更新的方式
   > 说明：不建议使用类似ORM框架的save(实体对象)的方式，建议使用类似SQL中的update语句的方式，如：

    ```
    db.users.update({_id:101}, {$set: {name: "zhangsan"}});
    ```
3. 【推荐】尽可能简化查询条件。
   > MongoDB对复杂查询的支持弱，查询条件语句难写、可读性差，复杂查询条件对查询性能的影响也高于关系型数据库，另外还有如前所述的索引对插入和更新的性能影响；  
   推荐摒弃SQL的查询思路，尽量使用主键和数组下标定位的方式来进行文档数据读取。MongoDB不应该被应用于复杂查询场景。
4. 【推荐】尽量使用具有明显顺序特征的条件字段过滤后再进行分页查询。
   > 说明：分页查询中的skip()是一个个文档进行跳跃的，执行效率低下，随着数据量的增加，性能急剧下降，跳跃10万个文档约需180ms；  
   分页查询应明确指定排序字段，且尽量使用具有明显顺序特征且分辨性强的字段或字段组合，如：精确到毫秒的时间戳、唯一性字符串等，在翻下一页时将当前页最后一个文档的排序字段值作为过滤条件加入分页查询中，以尽量减少skip()的跳跃次数。  
   另外，直接跳转到指定的第N页的功能，在N非常大时并不具有实际的业务意义，应该不予提供。
5. 【推荐】为查询条件字段添加索引可以有效提高获取总数的效率，也可以考虑使用冗余字段存放总数。
   > 说明：count()是一个个文档数出来结果的，获取总数的效率比skip()更加低下。为查询条件字段添加索引尽管可以提升count()效率，但会降低数据改动的效率。此时可以考虑使用冗余字段，在每次记录数量变化时更新统计数量。
6. 【推荐】删除spring-data-mongodb生成的_class字段。
   > 说明：spring-data-mongodb会为集合生成一个_class字段，存放对应实体的类名，以便于获知一个文档对应的实体类型，尤其是在有继承关系的情况下；  
   该字段由于带有完整包名，往往内容较长，占用较多的空间，且在类名或其包名更改时需进行特殊处理，在大多数没有继承关系的情况下，均建议删除。我们可以：

    ```java
    @Bean
    public MongoTemplate mongoTemplate() throws UnknownHostException {
        MappingMongoConverter mappingMongoConverter =  new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory()), new MongoMappingContext());
        mappingMongoConverter.setTypeMapper(new DefaultMongoTypeMapper(null));
        return new MongoTemplate(mongoDbFactory(), mappingMongoConverter );
    }
    ```
   > 查询时显式指定查询实体类型：

    ```java
    mongoTemplate.find(new Query(), User.class));
    ```

